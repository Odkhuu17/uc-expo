# This file was generated. Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"Requires that exactly one field must be supplied and that field must not be `null`."
directive @oneOf on INPUT_OBJECT

interface BaseModelInterface {
    createdAt: ISO8601DateTime!
    id: ID!
    updatedAt: ISO8601DateTime!
}

"An object with an ID."
interface Node {
    "ID of the object."
    id: ID!
}

union Image = Order

type Address implements BaseModelInterface {
    address1: String
    address2: String
    alternativeEmail: String
    alternativeMobile: String
    country: Country
    countryId: ID
    createdAt: ISO8601DateTime!
    district: District
    districtId: ID
    email: String
    firstName: String
    id: ID!
    lastName: String
    latitude: String
    location: Location
    longitude: String
    mobile: String
    name: String
    preferences: JSON!
    quarter: Quarter
    quarterId: ID
    sdq: [ID!]
    state: State
    stateId: ID
    updatedAt: ISO8601DateTime!
    zipcode: String
}

"The connection type for Address."
type AddressConnection {
    "A list of edges."
    edges: [AddressEdge!]!
    "A list of nodes."
    nodes: [Address!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type AddressEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Address
}

type Application implements BaseModelInterface {
    confidential: Boolean!
    createdAt: ISO8601DateTime!
    id: ID!
    name: String!
    redirectUri: String!
    scopes: String!
    secret: String!
    uid: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for Application."
type ApplicationConnection {
    "A list of edges."
    edges: [ApplicationEdge!]!
    "A list of nodes."
    nodes: [Application!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type ApplicationEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Application
}

type Country implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    id: ID!
    iso: String
    iso3: String
    isoName: String
    name: String!
    numCode: String
    sdq: JSON!
    states: [State!]!
    updatedAt: ISO8601DateTime!
}

type DeliveryRequest implements BaseModelInterface {
    active: Boolean!
    createdAt: ISO8601DateTime!
    id: ID!
    order: Order!
    price: Float!
    status: String!
    travelAt: ISO8601DateTime!
    updatedAt: ISO8601DateTime!
    user: User!
}

"The connection type for DeliveryRequest."
type DeliveryRequestConnection {
    "A list of edges."
    edges: [DeliveryRequestEdge!]!
    "A list of nodes."
    nodes: [DeliveryRequest!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type DeliveryRequestEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DeliveryRequest
}

type Device implements BaseModelInterface {
    application: Application!
    country: String
    createdAt: ISO8601DateTime!
    deviceModel: String
    deviceOs: String
    deviceType: String
    id: ID!
    language: String
    lastActive: ISO8601DateTime
    sessionsCount: Int!
    subscribed: Boolean!
    token: String
    updatedAt: ISO8601DateTime!
    user: User
}

"The connection type for Device."
type DeviceConnection {
    "A list of edges."
    edges: [DeviceEdge!]!
    "A list of nodes."
    nodes: [Device!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type DeviceEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Device
}

type District implements BaseModelInterface {
    abbr: String
    createdAt: ISO8601DateTime!
    id: ID!
    name: String!
    quarters: [Quarter!]!
    state: State!
    stateId: ID!
    ubcCode: String
    updatedAt: ISO8601DateTime!
    zipcode: String
}

"The connection type for District."
type DistrictConnection {
    "A list of edges."
    edges: [DistrictEdge!]!
    "A list of nodes."
    nodes: [District!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type DistrictEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: District
}

type ImageObject {
    fileName: String!
    id: ID!
    recordId: Int!
    recordType: String!
    url: String!
}

type Location implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    id: ID!
    latitude: Float
    longitude: Float
    updatedAt: ISO8601DateTime!
}

type Mark implements BaseModelInterface {
    code: String!
    createdAt: ISO8601DateTime!
    id: ID!
    name: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for Mark."
type MarkConnection {
    "A list of edges."
    edges: [MarkEdge!]!
    "A list of nodes."
    nodes: [Mark!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type MarkEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Mark
}

type Model implements BaseModelInterface {
    code: String!
    createdAt: ISO8601DateTime!
    id: ID!
    mark: Mark!
    markId: ID!
    name: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for Model."
type ModelConnection {
    "A list of edges."
    edges: [ModelEdge!]!
    "A list of nodes."
    nodes: [Model!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type ModelEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Model
}

type Mutation {
    "Checks if email or mobile registered"
    authCheckLogin(
        "Parameters for authCheckLogin"
        input: authCheckLoginInput!
    ): JSON!
    authRegister(
        "Parameters for authRegister"
        input: authRegisterInput!
    ): User
    checkPayment(
        "Parameters for checkPayment"
        input: checkPaymentInput!
    ): JSON
    closeOrder(
        "Parameters for closeOrder"
        input: closeOrderInput!
    ): Order
    createAddress(
        "Parameters for createAddress"
        input: createAddressInput!
    ): Address
    createDeliveryRequest(
        "Parameters for createDeliveryRequest"
        input: createDeliveryRequestInput!
    ): DeliveryRequest
    createImage(
        "Parameters for createImage"
        input: createImageInput!
    ): Image
    createIndexElastic(
        "Parameters for createIndexElastic"
        input: createIndexElasticInput!
    ): JSON
    createMark(
        "Parameters for createMark"
        input: createMarkInput!
    ): Mark
    createModel(
        "Parameters for createModel"
        input: createModelInput!
    ): Model
    createOrUpdatePasswordLocal(
        "Parameters for createOrUpdatePasswordLocal"
        input: createOrUpdatePasswordLocalInput!
    ): PasswordLocal
    createOrder(
        "Parameters for createOrder"
        input: createOrderInput!
    ): Order
    createPasswordVehicle(
        "Parameters for createPasswordVehicle"
        input: createPasswordVehicleInput!
    ): PasswordVehicle
    createPayment(
        "Parameters for createPayment"
        input: createPaymentInput!
    ): JSON
    createPaymentMethod(
        "Parameters for createPaymentMethod"
        input: createPaymentMethodInput!
    ): PaymentMethod
    createSendEmail(
        "Parameters for createSendEmail"
        input: createSendEmailInput!
    ): SendEmail
    createSubscription(
        "Parameters for createSubscription"
        input: createSubscriptionInput!
    ): Subscription
    createSubscriptionPlan(
        "Parameters for createSubscriptionPlan"
        input: createSubscriptionPlanInput!
    ): SubscriptionPlan
    createSystemMenu(
        "Parameters for createSystemMenu"
        input: createSystemMenuInput!
    ): SystemMenu
    createTruck(
        "Parameters for createTruck"
        input: createTruckInput!
    ): Truck
    createUser(
        "Parameters for createUser"
        input: createUserInput!
    ): User
    createUserAddress(
        "Parameters for createUserAddress"
        input: createUserAddressInput!
    ): UserAddress
    destroyAddress(
        "Parameters for destroyAddress"
        input: destroyAddressInput!
    ): Address
    destroyImage(
        "Parameters for destroyImage"
        input: destroyImageInput!
    ): Image
    destroyMark(
        "Parameters for destroyMark"
        input: destroyMarkInput!
    ): Mark
    destroyModel(
        "Parameters for destroyModel"
        input: destroyModelInput!
    ): Model
    destroyOrder(
        "Parameters for destroyOrder"
        input: destroyOrderInput!
    ): Order
    destroyPaymentMethod(
        "Parameters for destroyPaymentMethod"
        input: destroyPaymentMethodInput!
    ): PaymentMethod
    destroySendEmail(
        "Parameters for destroySendEmail"
        input: destroySendEmailInput!
    ): SendEmail
    destroySubscription(
        "Parameters for destroySubscription"
        input: destroySubscriptionInput!
    ): Subscription
    destroySubscriptionPlan(
        "Parameters for destroySubscriptionPlan"
        input: destroySubscriptionPlanInput!
    ): SubscriptionPlan
    destroySystemMenu(
        "Parameters for destroySystemMenu"
        input: destroySystemMenuInput!
    ): SystemMenu
    destroyTruck(
        "Parameters for destroyTruck"
        input: destroyTruckInput!
    ): Truck
    destroyUser(
        "Parameters for destroyUser"
        input: destroyUserInput!
    ): User
    destroyUserAddress(
        "Parameters for destroyUserAddress"
        input: destroyUserAddressInput!
    ): UserAddress
    feedLocation(
        "Parameters for feedLocation"
        input: feedLocationInput!
    ): TruckTrack
    linkDevice(
        "Parameters for linkDevice"
        input: linkDeviceInput!
    ): Device!
    resetPassword(
        "Parameters for resetPassword"
        input: resetPasswordInput!
    ): User
    sendEmailTest(
        "Parameters for sendEmailTest"
        input: sendEmailTestInput!
    ): JSON
    "Returns boolean whether sms is sent or not"
    sendOtp(
        "Parameters for sendOtp"
        input: sendOtpInput!
    ): User
    updateAddress(
        "Parameters for updateAddress"
        input: updateAddressInput!
    ): Address
    updateDeliveryRequest(
        "Parameters for updateDeliveryRequest"
        input: updateDeliveryRequestInput!
    ): DeliveryRequest
    updateMark(
        "Parameters for updateMark"
        input: updateMarkInput!
    ): Mark
    updateModel(
        "Parameters for updateModel"
        input: updateModelInput!
    ): Model
    updateOrder(
        "Parameters for updateOrder"
        input: updateOrderInput!
    ): Order
    updatePasswordLocal(
        "Parameters for updatePasswordLocal"
        input: updatePasswordLocalInput!
    ): PasswordLocal
    updatePasswordVehicle(
        "Parameters for updatePasswordVehicle"
        input: updatePasswordVehicleInput!
    ): PasswordVehicle
    updatePaymentMethod(
        "Parameters for updatePaymentMethod"
        input: updatePaymentMethodInput!
    ): PaymentMethod
    updateSendEmail(
        "Parameters for updateSendEmail"
        input: updateSendEmailInput!
    ): SendEmail
    updateSubscription(
        "Parameters for updateSubscription"
        input: updateSubscriptionInput!
    ): Subscription
    updateSubscriptionPlan(
        "Parameters for updateSubscriptionPlan"
        input: updateSubscriptionPlanInput!
    ): SubscriptionPlan
    updateSystemMenu(
        "Parameters for updateSystemMenu"
        input: updateSystemMenuInput!
    ): SystemMenu
    updateTruck(
        "Parameters for updateTruck"
        input: updateTruckInput!
    ): Truck
    updateUser(
        "Parameters for updateUser"
        input: updateUserInput!
    ): User
}

type Order implements BaseModelInterface {
    audio: String
    carType: String
    carWeight: String
    createdAt: ISO8601DateTime!
    deliveryRequests(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DeliveryRequestFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DeliveryRequestConnection!
    destination: UserAddress
    id: ID!
    imageObjects: [ImageObject!]
    images: [String!]
    my: Boolean
    number: String
    origin: UserAddress
    packageDimensions: String
    packageType: String
    packageWeight: String
    price: Float
    published: Boolean
    receiverMobile: String
    receiverName: String
    requested: Boolean
    senderMobile: String
    senderName: String
    status: String
    subscribed: Boolean!
    title: String
    travelAt: ISO8601DateTime
    travelDistance: String
    travelDuration: String
    updatedAt: ISO8601DateTime!
    user: User
    validPasswordLocal: Boolean
}

"The connection type for Order."
type OrderConnection {
    "A list of edges."
    edges: [OrderEdge!]!
    "A list of nodes."
    nodes: [Order!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type OrderEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Order
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PasswordLocal implements BaseModelInterface {
    active: Boolean!
    createdAt: ISO8601DateTime!
    firstName: String!
    id: ID!
    images(
        "mini, medium, product"
        size: String
    ): [String!]!
    lastName: String!
    number: String
    preferences: JSON
    registerNumber: String!
    status: String!
    updatedAt: ISO8601DateTime!
    user: User!
}

"The connection type for PasswordLocal."
type PasswordLocalConnection {
    "A list of edges."
    edges: [PasswordLocalEdge!]!
    "A list of nodes."
    nodes: [PasswordLocal!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type PasswordLocalEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PasswordLocal
}

type PasswordVehicle implements BaseModelInterface {
    category: String!
    chassisNumber: String
    createdAt: ISO8601DateTime!
    id: ID!
    images(
        "mini, medium, product"
        size: String
    ): [String!]!
    loadingCapacity: String
    plateNumber: String!
    preferences: JSON
    status: String
    type: String
    updatedAt: ISO8601DateTime!
    user: User!
    vin: String
    weight: String
}

"The connection type for PasswordVehicle."
type PasswordVehicleConnection {
    "A list of edges."
    edges: [PasswordVehicleEdge!]!
    "A list of nodes."
    nodes: [PasswordVehicle!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type PasswordVehicleEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PasswordVehicle
}

type Payment implements BaseModelInterface {
    amount: Float!
    createdAt: ISO8601DateTime!
    id: ID!
    number: String!
    paymentCaptureEvents: [PaymentCaptureEvent!]!
    paymentMethod: PaymentMethod!
    preferences: JSON
    referenceNo: String
    source: JSON
    status: String
    subscription: Subscription
    updatedAt: ISO8601DateTime!
}

type PaymentCaptureEvent implements BaseModelInterface {
    amount: Float!
    createdAt: ISO8601DateTime!
    id: ID!
    paymentId: Int
    preferences: JSON
    source: JSON
    updatedAt: ISO8601DateTime!
}

"The connection type for Payment."
type PaymentConnection {
    "A list of edges."
    edges: [PaymentEdge!]!
    "A list of nodes."
    nodes: [Payment!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type PaymentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Payment
}

type PaymentMethod implements BaseModelInterface {
    active: Boolean!
    createdAt: ISO8601DateTime!
    description: String
    id: ID!
    name: String!
    preferences: JSON
    testMode: Boolean!
    type: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for PaymentMethod."
type PaymentMethodConnection {
    "A list of edges."
    edges: [PaymentMethodEdge!]!
    "A list of nodes."
    nodes: [PaymentMethod!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type PaymentMethodEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: PaymentMethod
}

type Quarter implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    district: District!
    districtId: ID!
    id: ID!
    name: String!
    ubcCode: String
    updatedAt: ISO8601DateTime!
    zipcode: String
}

"The connection type for Quarter."
type QuarterConnection {
    "A list of edges."
    edges: [QuarterEdge!]!
    "A list of nodes."
    nodes: [Quarter!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type QuarterEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Quarter
}

type Query {
    address(id: ID!): Address
    addresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: AddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): AddressConnection!
    application(id: ID!): Application
    applications(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ApplicationConnection!
    country(iso: String!): Country!
    deliveryRequest(id: ID!): DeliveryRequest
    deliveryRequests(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DeliveryRequestFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DeliveryRequestConnection!
    devices(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DeviceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DeviceConnection!
    districts(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DistrictFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DistrictConnection!
    mark(id: ID!): Mark
    marks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: MarkFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): MarkConnection!
    me: User
    model(id: ID!): Model
    models(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: ModelFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): ModelConnection!
    "Fetches an object given its ID."
    node(
        "ID of the object."
        id: ID!
    ): Node
    "Fetches a list of objects given a list of IDs."
    nodes(
        "IDs of the objects."
        ids: [ID!]!
    ): [Node]!
    order(id: ID, number: String): Order
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OrderConnection!
    passwordLocal(id: ID): PasswordLocal
    passwordLocals(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PasswordLocalFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PasswordLocalConnection!
    passwordVehicle(id: ID!): PasswordVehicle
    passwordVehicles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PasswordVehicleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PasswordVehicleConnection!
    payment(id: ID, number: String): Payment
    paymentMethod(id: ID!): PaymentMethod!
    paymentMethods(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentMethodFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentMethodConnection!
    payments(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PaymentFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PaymentConnection!
    quarters(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: QuarterFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): QuarterConnection!
    queryTest: JSON
    searchAddress(
        location: LatLngInput,
        page: Int,
        "query"
        query: String
    ): [UbCab!]
    sendEmail(id: ID!): SendEmail
    sendEmails(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SendEmailFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SendEmailConnection!
    sms(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SmsFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SmsConnection!
    states(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: StateFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): StateConnection!
    subscription(id: ID!): Subscription
    subscriptionPlan(id: ID!): SubscriptionPlan
    subscriptionPlans(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SubscriptionPlanFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SubscriptionPlanConnection!
    subscriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SubscriptionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SubscriptionConnection!
    systemMenu(code: String, id: ID): SystemMenu
    systemMenus(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SystemMenuFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SystemMenuConnection!
    truck(id: ID!): Truck
    truckTrack(id: ID!): TruckTrack
    truckTracks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TruckTrackFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TruckTrackConnection!
    trucks(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: TruckFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): TruckConnection!
    user(id: ID!): User
    userAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAddressConnection!
    users(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserConnection!
}

type Role implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    id: ID!
    name: String
    updatedAt: ISO8601DateTime!
}

type SendEmail implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    email: String!
    id: ID!
    message: String!
    name: String!
    type: String
    updatedAt: ISO8601DateTime!
}

"The connection type for SendEmail."
type SendEmailConnection {
    "A list of edges."
    edges: [SendEmailEdge!]!
    "A list of nodes."
    nodes: [SendEmail!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type SendEmailEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SendEmail
}

type Sms implements BaseModelInterface {
    content: String
    createdAt: ISO8601DateTime!
    from: String
    id: ID!
    operator: String
    scheduledAt: ISO8601DateTime
    sender: String
    sentAt: ISO8601DateTime
    sourceId: Int
    sourceType: String
    status: String
    to: String
    updatedAt: ISO8601DateTime!
}

"The connection type for Sms."
type SmsConnection {
    "A list of edges."
    edges: [SmsEdge!]!
    "A list of nodes."
    nodes: [Sms!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type SmsEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Sms
}

type State implements BaseModelInterface {
    abbr: String
    country: Country!
    countryId: ID!
    createdAt: ISO8601DateTime!
    districts: [District!]!
    id: ID!
    name: String!
    quarters: [Quarter!]!
    ubcCode: String
    updatedAt: ISO8601DateTime!
    zipcode: String
}

"The connection type for State."
type StateConnection {
    "A list of edges."
    edges: [StateEdge!]!
    "A list of nodes."
    nodes: [State!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type StateEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: State
}

type Subscription implements BaseModelInterface {
    active: Boolean!
    autoRenew: Boolean!
    createdAt: ISO8601DateTime!
    endAt: ISO8601DateTime!
    id: ID!
    paymentStatus: String!
    payments: [Payment!]!
    startAt: ISO8601DateTime!
    subscriptionPlan: SubscriptionPlan!
    updatedAt: ISO8601DateTime!
    user: User!
    valid: Boolean!
}

"The connection type for Subscription."
type SubscriptionConnection {
    "A list of edges."
    edges: [SubscriptionEdge!]!
    "A list of nodes."
    nodes: [Subscription!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type SubscriptionEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Subscription
}

type SubscriptionPlan implements BaseModelInterface {
    active: Boolean!
    code: String!
    createdAt: ISO8601DateTime!
    duration: String!
    endAt: ISO8601DateTime
    id: ID!
    name: String!
    preferences: JSON
    price: Float!
    startAt: ISO8601DateTime!
    updatedAt: ISO8601DateTime!
}

"The connection type for SubscriptionPlan."
type SubscriptionPlanConnection {
    "A list of edges."
    edges: [SubscriptionPlanEdge!]!
    "A list of nodes."
    nodes: [SubscriptionPlan!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type SubscriptionPlanEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SubscriptionPlan
}

type SystemMenu implements BaseModelInterface {
    children: [SystemMenu!]
    code: String!
    createdAt: ISO8601DateTime!
    hasChildren: Boolean
    icon: String
    id: ID!
    link: String!
    name: String!
    parent: SystemMenu
    parentId: ID
    preferences: JSON
    slug: String!
    updatedAt: ISO8601DateTime!
}

"The connection type for SystemMenu."
type SystemMenuConnection {
    "A list of edges."
    edges: [SystemMenuEdge!]!
    "A list of nodes."
    nodes: [SystemMenu!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type SystemMenuEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: SystemMenu
}

type Truck implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    currentTrack: TruckTrack
    id: ID!
    importedDate: ISO8601DateTime
    manufacturedDate: ISO8601DateTime
    mark: Mark!
    markId: ID!
    model: Model!
    modelId: ID!
    netWeight: Int
    plateNumber: String
    serial: String
    updatedAt: ISO8601DateTime!
    user: User!
    userId: ID!
    weight: Int
}

"The connection type for Truck."
type TruckConnection {
    "A list of edges."
    edges: [TruckEdge!]!
    "A list of nodes."
    nodes: [Truck!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type TruckEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Truck
}

type TruckTrack implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    destination: Address
    id: ID!
    latitude: Float
    longitude: Float
    number: String
    order: Order
    origin: Address
    status: String
    updatedAt: ISO8601DateTime!
}

"The connection type for TruckTrack."
type TruckTrackConnection {
    "A list of edges."
    edges: [TruckTrackEdge!]!
    "A list of nodes."
    nodes: [TruckTrack!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type TruckTrackEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TruckTrack
}

type UbCab {
    _id: String!
    _index: String!
    _score: Float!
    _source: UbCabSource!
    _type: String!
    quarter: Quarter
}

type UbCabLocation {
    lat: Float!
    lon: Float!
}

type UbCabSource {
    location: UbCabLocation!
    nameEn: String!
    nameFullEn: String!
    nameFullMn: String!
    nameMn: String!
    nameShortEn: String!
    nameShortMn: String!
    regionType: Int!
}

type User implements BaseModelInterface {
    createdAt: ISO8601DateTime!
    deliveryRequests(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DeliveryRequestFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DeliveryRequestConnection!
    devices(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: DeviceFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): DeviceConnection!
    email: String
    firstName: String
    gender: String
    id: ID!
    isAdmin: Boolean!
    lastName: String
    mobile: String
    nickName: String
    orders(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: OrderFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): OrderConnection!
    passwordLocal(id: ID): PasswordLocal
    passwordVehicles(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: PasswordVehicleFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): PasswordVehicleConnection!
    registerNum: String
    role: String
    roles: [Role!]
    subscribed: Boolean
    subscriptions(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: SubscriptionFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): SubscriptionConnection!
    updatedAt: ISO8601DateTime!
    userAddresses(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        filter: UserAddressFilter,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        "Returns the elements skipping _n_ from the list."
        offset: Int,
        "Sorting functionality"
        sort: SortFilter
    ): UserAddressConnection!
    validPasswordLocal: Boolean
    validPasswordVehicle: Boolean
}

type UserAddress implements BaseModelInterface {
    address: Address!
    createdAt: ISO8601DateTime!
    id: ID!
    updatedAt: ISO8601DateTime!
    user: User!
}

"The connection type for UserAddress."
type UserAddressConnection {
    "A list of edges."
    edges: [UserAddressEdge!]!
    "A list of nodes."
    nodes: [UserAddress!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type UserAddressEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: UserAddress
}

"The connection type for User."
type UserConnection {
    "A list of edges."
    edges: [UserEdge!]!
    "A list of nodes."
    nodes: [User!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type UserEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User
}

"Payment Method"
enum PaymentMethodEnum {
    "Merchant"
    q_pay_merchant
}

"Sort Direction"
enum SortDirection {
    "Ascending"
    asc
    "Descending"
    desc
}

"duration of subscription plan"
enum SubscriptionPlanDurationEnum {
    "Day"
    day
    "5 minutes"
    minute
    "Month"
    month
    "Quarter"
    quarter
    "Week"
    week
    "Year"
    year
}

"An ISO 8601-encoded datetime"
scalar ISO8601DateTime

"Represents untyped JSON"
scalar JSON

scalar Upload

input AddressFilter {
    address1: StringFilter
    address2: StringFilter
    alternativeEmail: StringFilter
    alternativeMobile: StringFilter
    createdAt: DateFilter
    email: StringFilter
    firstName: StringFilter
    id: IDFilter
    lastName: StringFilter
    latitude: StringFilter
    longitude: StringFilter
    mobile: StringFilter
    name: StringFilter
    updatedAt: DateFilter
    zipcode: StringFilter
}

input AddressInput {
    address1: String
    address2: String
    alternativeEmail: String
    alternativeMobile: String
    email: String
    firstName: String
    lastName: String
    location: LatLngInput
    mobile: String
    name: String
    preferences: JSON
    zipcode: String
}

input BoolFilter {
    "equals to"
    eq: Boolean
    "not equals to"
    notEq: Boolean
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
}

input DateFilter {
    "equals to"
    eq: String
    "Greater than"
    gt: String
    "Greater than or equals"
    gteq: String
    "Less than"
    lt: String
    "Less than or equals"
    lteq: String
    "not equals to"
    notEq: String
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
}

input DeliveryRequestFilter {
    createdAt: DateFilter
    id: IDFilter
    order: OrderFilter
    updatedAt: DateFilter
}

input DeviceFilter {
    applicationId: IDFilter
    createdAt: DateFilter
    deviceModel: StringFilter
    deviceOs: StringFilter
    deviceType: StringFilter
    id: IDFilter
    ipAddress: StringFilter
    lastActive: DateFilter
    subscribed: BoolFilter
    token: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    userId: IDFilter
}

input DistrictFilter {
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    stateId: IDFilter
    ubcCode: StringFilter
    updatedAt: DateFilter
}

input IDFilter {
    "is null ?"
    blank: Boolean
    "equals to"
    eq: ID
    "Greater than"
    gt: Int
    "Greater than or equals"
    gteq: Int
    "in: Matches any values in giver array"
    in: [ID!]
    "Less than"
    lt: Int
    "Less than or equals"
    lteq: Int
    "not equals to"
    notEq: ID
    "in: Matches none of values in giver array"
    notIn: [ID!]
    "Starts with"
    start: Int
}

input IntFilter {
    "is blank ?"
    blank: Boolean
    "equals to"
    eq: Float
    "Greater than"
    gt: Float
    "Greater than or equals"
    gteq: Float
    "in: Matches none of values in giver array"
    in: [Float!]
    "Less than"
    lt: Float
    "Less than or equals"
    lteq: Float
    "not equals to"
    notEq: Float
    "in: Matches none of values in giver array"
    notIn: [Float!]
    "is null ?"
    null: Boolean
}

input LatLngInput {
    "Latitude"
    latitude: Float!
    "Longitude"
    longitude: Float!
}

input MarkFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input ModelFilter {
    code: StringFilter
    createdAt: DateFilter
    id: IDFilter
    mark: MarkFilter
    name: StringFilter
    updatedAt: DateFilter
}

input OrderFilter {
    carType: StringFilter
    carWeight: StringFilter
    createdAt: DateFilter
    id: IDFilter
    number: StringFilter
    packageDimensions: StringFilter
    packageType: StringFilter
    packageWeight: StringFilter
    price: IntFilter
    receiverMobile: StringFilter
    receiverName: StringFilter
    senderMobile: StringFilter
    senderName: StringFilter
    status: StringFilter
    title: StringFilter
    travelAt: DateFilter
    travelDistance: StringFilter
    travelDuration: StringFilter
    updatedAt: DateFilter
}

input PasswordLocalFilter {
    createdAt: DateFilter
    id: IDFilter
    status: StringFilter
    updatedAt: DateFilter
}

input PasswordVehicleFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input PaymentFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input PaymentMethodFilter {
    active: BoolFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input QuarterFilter {
    createdAt: DateFilter
    districtId: IDFilter
    id: IDFilter
    name: StringFilter
    ubcCode: StringFilter
    updatedAt: DateFilter
}

input SendEmailFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input SmsFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input SortFilter {
    direction: SortDirection
    field: String!
}

input StateFilter {
    abbr: StringFilter
    countryId: IDFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    ubcCode: StringFilter
    updatedAt: DateFilter
}

input StringFilter {
    "is blank ?"
    blank: Boolean
    "contains"
    cont: String
    "ends with"
    end: String
    "equals to"
    eq: String
    "in: Matches any values in giver array"
    in: [String!]
    "not equals to"
    notEq: String
    "in: Matches none of values in giver array"
    notIn: [String!]
    "is null ?"
    notNull: Boolean
    "is null ?"
    null: Boolean
    "starts with"
    start: String
}

input SubscriptionFilter {
    createdAt: DateFilter
    id: IDFilter
    paymentStatus: IntFilter
    subscriptionPlan: SubscriptionPlanFilter
    subscriptionPlanId: IDFilter
    updatedAt: DateFilter
    user: UserFilter
    userId: IDFilter
    valid: BoolFilter
}

input SubscriptionPlanFilter {
    active: BoolFilter
    createdAt: DateFilter
    id: IDFilter
    name: StringFilter
    updatedAt: DateFilter
}

input SystemMenuFilter {
    createdAt: DateFilter
    id: IDFilter
    parentId: IDFilter
    updatedAt: DateFilter
}

input TruckFilter {
    createdAt: DateFilter
    id: IDFilter
    importedDate: DateFilter
    manufacturedDate: DateFilter
    mark: MarkFilter
    model: ModelFilter
    netWeight: IntFilter
    plateNumber: StringFilter
    serial: StringFilter
    updatedAt: DateFilter
    user: UserFilter
    weight: IntFilter
}

input TruckTrackFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input UserAddressFilter {
    createdAt: DateFilter
    id: IDFilter
    updatedAt: DateFilter
}

input UserFilter {
    createdAt: DateFilter
    email: StringFilter
    firstName: StringFilter
    gender: StringFilter
    id: IDFilter
    lastName: StringFilter
    mobile: StringFilter
    nickName: StringFilter
    registerNum: StringFilter
    role: IntFilter
    updatedAt: DateFilter
}

"Autogenerated input type of authCheckLogin"
input authCheckLoginInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Login email or mobile"
    login: String!
    sendToken: Boolean
}

"Autogenerated input type of authRegister"
input authRegisterInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String!
    lastName: String!
    login: String!
    password: String!
    token: String!
}

"Autogenerated input type of checkPayment"
input checkPaymentInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    invoiceNo: ID!
}

"Autogenerated input type of closeOrder"
input closeOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    mobile: String!
    number: String!
}

"Autogenerated input type of createAddress"
input createAddressInput {
    address1: String
    address2: String
    alternativeEmail: String
    alternativeMobile: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    countryId: ID
    districtId: ID
    email: String
    firstName: String
    lastName: String
    location: LatLngInput
    mobile: String
    name: String
    preferences: JSON
    quarterId: ID
    sdq: [ID!]
    stateId: ID
    ubcCode: String
    zipcode: String
}

"Autogenerated input type of createDeliveryRequest"
input createDeliveryRequestInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    orderId: ID!
    price: Float!
    travelAt: ISO8601DateTime!
    userId: ID
}

"Autogenerated input type of createImage"
input createImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Class ID"
    id: ID!
    "Image ID"
    images: [Upload!]!
    "Supp::Menu or Supp::Page"
    type: String!
}

"Autogenerated input type of createIndexElastic"
input createIndexElasticInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    name: String!
}

"Autogenerated input type of createMark"
input createMarkInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    name: String!
}

"Autogenerated input type of createModel"
input createModelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    markId: ID!
    name: String!
}

"Autogenerated input type of createOrUpdatePasswordLocal"
input createOrUpdatePasswordLocalInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String!
    images: [Upload!]!
    lastName: String!
    number: String
    registerNumber: String!
    userId: ID
}

"Autogenerated input type of createOrder"
input createOrderInput {
    audio: Upload
    carType: String
    carWeight: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    destination: AddressInput
    destinationId: ID
    images: [Upload!]
    origin: AddressInput
    originId: ID
    packageDimensions: Float
    packageType: String
    packageWeight: Float
    price: String
    published: Boolean
    receiverMobile: String
    receiverName: String
    senderMobile: String
    senderName: String
    title: String
    travelAt: ISO8601DateTime
    travelDistance: Float
    travelDuration: Float
    userId: ID
}

"Autogenerated input type of createPasswordVehicle"
input createPasswordVehicleInput {
    category: String!
    chassisNumber: String!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    images: [Upload!]!
    loadingCapacity: String!
    plateNumber: String!
    preferences: JSON
    userId: ID
    vehicleType: String!
    vin: String!
    weight: String!
}

"Autogenerated input type of createPayment"
input createPaymentInput {
    "q_pay_merchant"
    action: PaymentMethodEnum!
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    subscriptionPlanId: ID!
}

"Autogenerated input type of createPaymentMethod"
input createPaymentMethodInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    name: String!
    preferences: JSON
    testMode: Boolean
    "Supp::PaymentMethod::QPay::Merchant"
    type: String!
}

"Autogenerated input type of createSendEmail"
input createSendEmailInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String!
    message: String!
    name: String!
}

"Autogenerated input type of createSubscription"
input createSubscriptionInput {
    autoRenew: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    endAt: ISO8601DateTime
    startAt: ISO8601DateTime
    subscriptionPlanId: ID!
    userId: ID!
}

"Autogenerated input type of createSubscriptionPlan"
input createSubscriptionPlanInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    "monthly only for now"
    duration: SubscriptionPlanDurationEnum!
    endAt: ISO8601DateTime
    name: String!
    preferences: JSON
    price: Float!
    startAt: ISO8601DateTime
}

"Autogenerated input type of createSystemMenu"
input createSystemMenuInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String!
    icon: String
    link: String!
    name: String!
    parentCode: String
    parentId: ID
    position: Int
    preferences: JSON
    slug: String
}

"Autogenerated input type of createTruck"
input createTruckInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    importedDate: ISO8601DateTime
    manufacturedDate: ISO8601DateTime
    markId: ID!
    modelId: ID!
    netWeight: Int
    plateNumber: String
    serial: String
    userId: ID!
    weight: Int
}

"Autogenerated input type of createUserAddress"
input createUserAddressInput {
    address1: String
    address2: String
    alternativeEmail: String
    alternativeMobile: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    firstName: String
    lastName: String
    location: LatLngInput
    mobile: String
    name: String
    preferences: JSON
    userId: ID
    zipcode: String
}

"Autogenerated input type of createUser"
input createUserInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    firstName: String!
    gender: String
    lastName: String
    mobile: String!
    nickName: String
    password: String!
}

"Autogenerated input type of destroyAddress"
input destroyAddressInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyImage"
input destroyImageInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "Menu ID"
    id: ID!
    "Image ID"
    imageId: ID!
    "Supp::Menu or Supp::Page"
    type: String!
}

"Autogenerated input type of destroyMark"
input destroyMarkInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyModel"
input destroyModelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyOrder"
input destroyOrderInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyPaymentMethod"
input destroyPaymentMethodInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroySendEmail"
input destroySendEmailInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroySubscription"
input destroySubscriptionInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroySubscriptionPlan"
input destroySubscriptionPlanInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroySystemMenu"
input destroySystemMenuInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyTruck"
input destroyTruckInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyUserAddress"
input destroyUserAddressInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of destroyUser"
input destroyUserInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
}

"Autogenerated input type of feedLocation"
input feedLocationInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    deviceToken: String
    latitude: Float!
    longitude: Float!
    truckId: ID!
}

"Autogenerated input type of linkDevice"
input linkDeviceInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    country: String
    deviceModel: String
    deviceOs: String
    deviceType: String
    subscribed: Boolean
    token: String!
}

"Autogenerated input type of resetPassword"
input resetPasswordInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    login: ID!
    password: String!
    token: String!
}

"Autogenerated input type of sendEmailTest"
input sendEmailTestInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    title: String
}

"Autogenerated input type of sendOtp"
input sendOtpInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    "User ID"
    id: ID
    "Mobile or email"
    login: String!
}

"Autogenerated input type of updateAddress"
input updateAddressInput {
    address1: String
    address2: String
    alternativeEmail: String
    alternativeMobile: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    countryId: ID
    districtId: ID
    email: String
    firstName: String
    id: ID!
    lastName: String
    latitude: String
    location: LatLngInput
    longitude: String
    mobile: String
    name: String
    preferences: JSON
    quarterId: ID
    stateId: ID
    ubcCode: String
    zipcode: String
}

"Autogenerated input type of updateDeliveryRequest"
input updateDeliveryRequestInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    "pending, accepted, rejected"
    status: String!
}

"Autogenerated input type of updateMark"
input updateMarkInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    id: ID!
    name: String
}

"Autogenerated input type of updateModel"
input updateModelInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    id: ID!
    markId: ID
    name: String
}

"Autogenerated input type of updateOrder"
input updateOrderInput {
    carType: String
    carWeight: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    destinationId: ID
    id: ID!
    originId: ID
    packageDimensions: String
    packageImages: [Upload!]
    packageImagesBase64: [String!]
    packageType: String
    packageWeight: String
    price: String
    "  "
    published: Boolean
    receiverMobile: String
    receiverName: String
    senderMobile: String
    senderName: String
    status: String
    title: String
    travelAt: ISO8601DateTime
    travelDistance: String
    travelDuration: String
}

"Autogenerated input type of updatePasswordLocal"
input updatePasswordLocalInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String
    id: ID!
    images: [Upload!]
    lastName: String
    preferences: JSON
    registerNumber: String
    "pending, approved, rejected"
    status: String
}

"Autogenerated input type of updatePasswordVehicle"
input updatePasswordVehicleInput {
    category: String
    chassisNumber: String
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    images: [Upload!]
    loadingCapacity: String
    plateNumber: String
    preferences: JSON
    "pending, approved, rejected"
    status: String
    userId: ID
    vehicleType: String
    vin: String
    weight: String
}

"Autogenerated input type of updatePaymentMethod"
input updatePaymentMethodInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    description: String
    id: ID!
    name: String
    preferences: JSON
    testMode: Boolean
    "Supp::PaymentMethod::QPay::Merchant"
    type: String
}

"Autogenerated input type of updateSendEmail"
input updateSendEmailInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    email: String
    id: ID!
    message: String
    name: String
}

"Autogenerated input type of updateSubscription"
input updateSubscriptionInput {
    autoRenew: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    endAt: ISO8601DateTime
    id: ID!
    startAt: ISO8601DateTime
    subscriptionPlanId: ID
    userId: ID
}

"Autogenerated input type of updateSubscriptionPlan"
input updateSubscriptionPlanInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    "monthly only for now"
    duration: String
    endAt: ISO8601DateTime
    id: ID!
    name: String
    preferences: JSON
    price: Float
    startAt: ISO8601DateTime
}

"Autogenerated input type of updateSystemMenu"
input updateSystemMenuInput {
    active: Boolean
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    code: String
    icon: String
    id: ID!
    link: String
    name: String
    parentId: ID
    position: Int
    preferences: JSON
    slug: String
}

"Autogenerated input type of updateTruck"
input updateTruckInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    id: ID!
    importedDate: ISO8601DateTime
    manufacturedDate: ISO8601DateTime
    markId: ID!
    modelId: ID!
    netWeight: Int
    plateNumber: String
    serial: String
    userId: ID!
    weight: Int
}

"Autogenerated input type of updateUser"
input updateUserInput {
    "A unique identifier for the client performing the mutation."
    clientMutationId: String
    firstName: String
    gender: String
    id: ID!
    lastName: String
    nickName: String
}
